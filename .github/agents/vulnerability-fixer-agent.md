# Vulnerability Fixing Agent

Purpose: automated guidance for AI agents that locate, reproduce, and prepare fixes for security or dependency vulnerabilities in this repository.

Key capabilities required
- Shell access: run commands, install small tools, run linters/scanners.
- Git: create branches, commit, push, open PRs.
- Programmatic web search / OS network access: fetch CVE details, vendor advisories, and package advisory pages (use `curl`/`httpie` or the platform's web-search plugin).
- File write access: update source files and tests in the workspace.

Required tools (suggested)
- `python` 3.10+ and `pip` — run examples and install local scanning tools.
- `pip-audit` — dependency vulnerability scanner: `pip install pip-audit` then `pip-audit`.
- `bandit` — static-security scanner for Python: `pip install bandit` then `bandit -r .`.
- `safety` (optional): `pip install safety` and `safety check --full-report`.
- `git`, `curl`/`httpie`, and `jq` for scripting and parsing.

Workspace assumptions
- Dependencies are declared in `pyproject.toml` and examples live in `chapterone` (`chapterone/main.py`, `chapterone/one.py`).
- There are no automated tests included; reproduction steps should be added as runnable examples or minimal tests where possible.

Agent workflow (step-by-step)
1. Discover
   - Run `pip-audit` to list vulnerable packages: `pip-audit --format json | jq '.'`.
   - Run `bandit -r . -f json` to surface static issues.
   - Inspect `pyproject.toml` for direct dependency versions to prioritize fixes.
2. Triage & Research
   - For each finding, fetch the CVE/advisory page (use web-search plugin or `curl`) and capture the advisory URL and severity.
   - Reproduce locally: create a tiny script or run the example that touches the vulnerable code path.
3. Prepare fix branch
   - Create a branch: `git checkout -b ai/fix/vuln-<pkg>-YYYYMMDD`.
   - Small dependency fixes: prefer pinning to a secure release in `pyproject.toml` and `pip install -e .` to test.
   - Code fixes: make the minimal safe change and include a short unit or repro test under `chapter*` demonstrating the fix.
4. Validate
   - Re-run `pip-audit` / `bandit` to ensure the issue is resolved.
   - Run example scripts: `python chapterone/main.py` and `python chapterone/one.py` to smoke-test behavior.
5. Commit & PR
   - Commit message format: `fix(vuln): <short description> — <advisory URL>`.
   - Push and open a PR with a short summary, list of changed files, reproduction steps, and advisory links.

Safety & rules of engagement
- Never commit secrets or `.env` contents. If reproduction requires credentials, document steps for the reviewer and skip committing keys.
- Avoid large dependency bumps without testing — prefer patch/minor updates when feasible and document rationale.
- If a fix requires changing `trust_remote_code` or `device_map` device usage, call it out explicitly in the PR description and explain memory/compatibility impact.

Output expectations
- The agent should produce a PR with:
  - Branch name and commit(s) that contain the minimal fix.
  - A clear PR description with advisory links and reproduction steps.
  - Optional: a new test or a runnable example illustrating the reproduction and the fix.

Permissions & environment notes for operator
- Agent needs permission to push branches and open PRs, or should produce a patch/branch the human maintainer can review and push.
- For network-restricted environments, the agent should save advisory URLs and data instead of trying to fetch them.

References
- See `pyproject.toml` for declared dependencies.
- Example files to run for smoke tests: `chapterone/main.py`, `chapterone/one.py`.

If you'd like, I can also add a small CI job example that runs `pip-audit` and `bandit` on PRs — tell me whether you prefer GitHub Actions or another CI provider.
